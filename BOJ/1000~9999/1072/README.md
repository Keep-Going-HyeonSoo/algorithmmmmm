📅 Date: 2021-12-22 (화)

# 1072. 게임
출처: https://www.acmicpc.net/problem/1072

## 📝 Problem

### 문제
김형택은 지금 몰래 Spider Solitaire(스파이더 카드놀이)를 하고 있다. 형택이는 이 게임을 이길 때도 있었지만, 질 때도 있었다. 누군가의 시선이 느껴진 형택이는 게임을 중단하고 코딩을 하기 시작했다. 의심을 피했다고 생각한 형택이는 다시 게임을 켰다. 그 때 형택이는 잠시 코딩을 하는 사이에 자신의 게임 실력이 눈에 띄게 향상된 것을 알았다.

이제 형택이는 앞으로의 모든 게임에서 지지 않는다. 하지만, 형택이는 게임 기록을 삭제 할 수 없기 때문에, 자신의 못하던 예전 기록이 현재 자신의 엄청난 실력을 증명하지 못한다고 생각했다.

게임 기록은 다음과 같이 생겼다.

게임 횟수 : X
이긴 게임 : Y (Z %)
Z는 형택이의 승률이다. 소수점은 버린다. 예를 들어, X=53, Y=47이라면, Z = 88이다.
X와 Y가 주어졌을 때, 형택이가 게임을 최소 몇 판 더 해야 Z가 변하는지 구하는 프로그램을 작성하시오.

### 입력
각 줄에 X와 Y가 주어진다. X는 1,000,000,000보다 작거나 같은 자연수이고, Y는 0보다 크거나 같고, X보다 작거나 같은 자연수이다.


### 출력
첫째 줄에 형택이가 게임을 최소 몇 판 더 해야하는지 출력한다. 만약 Z가 절대 변하지 않는다면 -1을 출력한다.

## Input/Output example
### Input 1

```
10 8
```

### Output 1
```
1
```

### Input 2

```
100 80
```

### Output 2
```
6
```

# ✅ Submit
## 👌 Solved Code 1 

❌ 시간초과로 에러

### 💡 Idea

새로 계산한 z 와 temp 값이 달라질 때까지 계속 while 루프를 돌린다.
완전탐색을 이용한다.

### 💻 Code
(Important part only)

``` python
# 1072_2.py
# 시간초과
import sys

while True:
  try: 
    x, y = map(int, sys.stdin.readline().split())
    z = (y*100) // x
    cnt = 0
    temp = z

    if(z == 99 or z == 100):
      print(-1)
    else:
      while(z == temp):
        x += 1
        y += 1
        z = (y*100) // x
        cnt += 1
      print(cnt)

  except: break
```

### ✍ Solution
- 기존 승률이 99% 였다면, 앞으로의 게임 아무리 다 이겨도 100%는 불가능하다. 따라서 99%와 100%는 if문으로 걸러준다.
- x, y 를 1씩 증가시키면서 달라지는 승률인 z 와 기존 승률 temp 를 비교한다. z != temp 가 되는 최초의 루프에서의 cnt 값이 정답이 된다.

### 💬 Commentary
- x 의 최댓값이 10억이라서 y를 9.8999..억으로 둬서 승률을 98.99..%라 가정하면(어차피 99%는 if문으로 걸러주니까), 필요한 게임 판수가 대략 10억보다 살짝 더 나온다. 즉 최악의 경우 `10억 * (연산횟수)` 를 수행해야하므로 시간복잡도가 어마어마하게 커진다. 따라서 완전탐색으로는 풀 수가 없다는 결론이 나온다.
- 이 문제는 입력쌍의 갯수가 지정돼있지 않다. 따라서 입력을 받을 때, try 문 안에서 입력이 들어오지 않을 때(=EOFError) 에러가 나기 때문에 except 로 분기를 시켜줬다. ( 임의의 여러줄 입력이 들어올 때 스킬! )

<br>

## 👌 Solved Code 2

### 💡 Idea

⭕ 이분탐색으로 변경

### 💻 Code
(Important part only)

``` python
# 1072_1.py

import sys

while True:
  try: 
    x, y = map(int, sys.stdin.readline().split())
    z = (y*100) // x  # z = (y//x) * 100 는 틀리게 됨
    temp = z

    if(z == 99 or z == 100):
      print(-1)
    else:
      start, end = 1, 1500000000 # end 값은 x가 10억, y가 9.899..억 일때를 계산해서 나온 값 ( 좀 여유있게 설정함 )
      while(start <= end):
        mid = (start + end) // 2
        new_z = ((y+mid)*100 // (x+mid))  # ((y+mid) // (x+mid)) * 100 는 틀리게 됨
        if( new_z > temp ):
          result = mid
          end = mid - 1
        else:
          start = mid + 1

      print(result)
          
  except: break
```

### ✍ Solution
- end 값은 적당히 여유있게 설정했다.
- 우리가 찾고자하는 값은 mid 값에 들어올 것이다.
- `start <= end` 동안 이분탐색을 진행하는데, 조건문은 새로 계산한 승률인 new_z 가 기존 승률보다 크면, 찾을 범위를 왼쪽으로 조정(mid 값을 감소)시킨다. 이유는 `(y+mid) / (x+mid)` 의 분수형태에서 mid 값이 작아지면 분수 전체가 작아지고, mid 값이 커지면 분수 전체가 커지기 때문이다.

### 💬 Commentary
- 맨 처음에는 이분탐색이 `new_z > temp` 가 되는 **최소**의 mid 값을 찾아줄 수 있나? 하는 의문이 들었는데, new_z > temp 인 경우를 한 번 만족했다고 해서 루프를 멈추는 것이 아니라 start <= end 일 동안 계~속 루프를 도니까 왔다갔다 하면서 결국은 최소의 mid 값을 찾게 된다.
- `(y*100) // x` 와 `(y//x) * 100` 가 같은 거 아니냐? 라고 생각할 수 있지만, 결과는 천지차이다. 전자는 맞게 채점되고, 후자는 틀리게 채점된다. 이유는 확실히 모르겠는데 전자처럼 먼저 곱셈을 해서 큰 수로 만들어주고 나눗셈을 하는 것이 부동소수점 연산에서 조금 더 정확한 값을 얻는 것 같다. 

## References
- [[BOJ 1072] 게임(C++)](https://real-012.tistory.com/125)